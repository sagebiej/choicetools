#' Assign Labels to Data Generated by SurveyEngine
#'
#' This function reads a dictionary file and assigns labels to variables in a dataset
#' generated by SurveyEngine.
#'
#' @param path Character string. The file path to the Excel file containing the dataset and dictionary.
#' @param seelab Logical. If `TRUE`, displays messages about variable labeling. Default is `TRUE`.
#' @param lower Logical. If `TRUE`, converts variable names to lowercase. Default is `FALSE`.
#' @param sheet Character string. The sheet name in the Excel file that contains the dictionary. Default is `"Dictionary"`.
#'
#' @return A data frame with assigned variable labels and, where applicable, value labels.
#'
#' @details
#' This function reads variable labels from an Excel file, checks for inconsistencies
#' between dataset variables and the label set, and assigns labels accordingly.
#' If there are unmatched variables, a message will be displayed.
#'
#' The function performs the following steps:
#' - Reads the label dictionary from the specified sheet.
#' - Checks if all variables in the dataset have corresponding labels.
#' - Assigns variable labels as attributes.
#' - Assigns value labels if available.
#'
#' @importFrom readxl read_excel
#' @importFrom dplyr rename
#' @importFrom zoo na.locf
#' @importFrom janitor row_to_names
#'
#' @examples
#' \dontrun{
#' # Assign labels to a dataset
#' labeled_data <- ass_labels("survey_data.xlsx", seelab = TRUE, lower = TRUE)
#' }
#'
#' @export

ass_labels <- function(path, seelab = TRUE, lower = FALSE, sheet = "Dictionary") {
  labels <- readxl::read_excel(path = path, sheet = sheet, col_names = TRUE)[-2:-1, 2:4] %>%
    dplyr::rename("Variable" = 1, "Labels" = 2, "valuelabels" = 3)


  if (lower == TRUE) labels$Variable <- tolower(labels$Variable)


  covdata <- readxl::read_excel(path = path)


  ## check if variables are all present
  # test 1

  cat(
    "Number of variables in dataset: ", length(names(covdata)),
    "\n Number of variables in label set:", length(labels$Variable[!is.na(labels$Variable)]), "\n"
  )

  if (length(names(covdata)) != length(labels$Variable[!is.na(labels$Variable)])) {
    cat(
      "\n labels do not match, will be ignored, but make sure this is ok.
           \n Below are the variables that are problematic. \n \n These variables exist in the dataset but not in the label set:",
      setdiff(names(covdata), labels$Variable[!is.na(labels$Variable)]),
      "\n and these exist in the labels and not in the dataset:",
      setdiff(labels$Variable[!is.na(labels$Variable)], names(covdata))
    )
  }

  for (vn in names(covdata)) {
    attr(covdata[[vn]], "label") <- toString(labels[which(labels$Variable == vn), "Labels"])
  }


  labels$Variable <- zoo::na.locf(labels$Variable)
  labels <- labels[!is.na(labels$Labels), ]

  X <- base::split(labels, labels$Variable)

  Y <- lapply(X, janitor::row_to_names, row_number = 1)


  for (vn in names(covdata)) {
    if (is.null(attr(covdata[[vn]], "class")) == TRUE) {
      attr(covdata[[vn]], "class") <- "haven_labelled"
    }


    if (exists(vn, Y) == TRUE && nrow(Y[[vn]]) > 1) {
      if (seelab == TRUE) cat("\n the variable", vn, " will be labelled \n")

      t <- as.numeric(unlist(Y[[vn]][2]))
      names(t) <- unlist(Y[[vn]][3])
      attr(covdata[[vn]], "labels") <- t
    } else {
      if (seelab == TRUE) cat("\n Attention: the values of the variable", vn, " will NOT be labelled \n")
    }
  }

  return(covdata)
}
